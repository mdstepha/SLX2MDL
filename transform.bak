#!/usr/bin/python3


from commons import *
from tags_model import *
from transform_stateflow import stateflow_xml2mdl


class Transformer:
    # controls whether to preetify the output mdl
    # This can be overridden from Transformer.initialize() 
    _preetify = False  

    filepath_slx = None  # input
    filepath_mdl = None  # output
    filepath_original_mdl = None
    filepath_original_mdl_preetified = None
    dirpath_working = None
    dirpath_slx_extracted = None
    filepath_merged_commented = None
    filepath_merged_uncommented = None

    filepath_stateflow = None
    filepath_stateflow_preprocessed = None

    filepath_output_model_only_unpreetified = None
    filepath_output_model_only_preetified = None
    filepath_output_stateflow_only = None

    filepath_merged_commented_no_multiline_str_content = None
    filepath_merged_uncommented_no_multiline_str_content = None
    filepath_mdl_unpreetified = None
    filepath_mdl_preetified = None

    filename_original_mdl_at_current_directory = 'original.mdl'
    filename_output_mdl_at_current_directory = 'output.mdl'

    

    @classmethod
    def _extract_slx_archive(cls):
        """Extract slx archive (located in cls.filepath_slx).
        The extracted files will be in cls.dirpath_slx_extracted"""
        with zipfile.ZipFile(cls.filepath_slx, 'r') as zip_ref:
            zip_ref.extractall(cls.dirpath_slx_extracted)

    @classmethod
    def _merge_xmls(cls, output_filepath):
        """Merge xml files in the slx archive into one big xml file
        Some xml files (eg. stateflow.xml) won't be merged.
        """


        # files are in the order in which the corresponding information appears in the final mdl file
        # while this is not a requirement, it will keep the information look more 'organized' to a human reader.
        files = [
            'simulink/blockdiagram.xml',
            'simulink/windowsInfo.xml',
            # 'slx-files/metadata/coreProperties.xml',
            
            # plugins
            'simulink/plugins/AnimationPlugin',  # first found in sldemo_suspn ;
            'simulink/plugins/DiagnosticSuppressor.xml',
            'simulink/plugins/LogicAnalyzerPlugin.xml',
            'simulink/plugins/NotesPlugin.xml',
            'simulink/plugins/SLCCPlugin.xml',
            'simulink/plugins/WebScopes_FoundationPlugin.xml',

            'simulink/configSet0.xml',
            'simulink/bddefaults.xml',
            # 'simulink/configSetInfo.xml',
            'simulink/graphicalInterface.xml',
        ]
        with open(output_filepath, 'w') as wfile:
            for f in files:
                # it is not guarranted that every slx files contains all of these xml files
                # so we proceed only if the file exists.
                p = os.path.join(cls.dirpath_working, 'slx-files', f)
                if os.path.exists(p):
                    with open(p) as rfile:
                        wfile.write('\n\n')
                        comment = f'<!--{f[9:]}-->'  # filename inside comment

                        rfile.readline()  # skip first line
                        for line in rfile:

                            if p.endswith('blockdiagram.xml'):  # file-specific processing
                                # skip <ModelInformation...> and its closing tag (of blockdiagram.xml)
                                if 'ModelInformation' in line:
                                    continue
                                # don't write the last line yet.
                                if line.strip() == '</Model>':
                                    roottag = 'Model'
                                    continue
                                # don't write the last line yet.
                                if line.strip() == '</Library>':
                                    roottag = 'Library'
                                    continue

                            line = line[:-1] + comment + '\n'
                            # IMPORTANT: NEVER ADD ANY INDENTATION I.E. NEVER ADD ANY EXTRA SPACES TO THE 
                            # LEFT OF THE LINES WHEN WRITING THEM TO THE FILE. OTHERWISE, WE WILL END UP 
                            # WITH INVALID STRINGS (FOR MULTILINE STRING CONTENTS). THIS BECOMES FATAL 
                            # SOMETIMES -- FOR EXAMPLE: THIS CAN CAUSE INVLID PATH REFERENCES TO LIBRARY 
                            # ELEMENTS AND HENCE CORRUPT THE MODEL. 
                            wfile.write(line)

            # finally write the closing tag for <Model> or <Library>
            wfile.write(f'</{roottag}>')
           

    @classmethod
    def initialize(cls, filepath_slx, filepath_mdl=None, dirpath_working='/tmp/slx2mdl-working-dir', preetify=True):
        """Initialize the transformer."""
        cls._preetify = preetify 

        # define all necessary file and directory paths
        # we will always use absolute paths
        cls.filepath_slx = os.path.abspath(filepath_slx)
        cls.dirpath_working = os.path.abspath(dirpath_working)
        filepath_mdl = filepath_mdl or os.path.join(cls.dirpath_working, 'output.mdl')
        cls.filepath_mdl = os.path.abspath(filepath_mdl)

        # the path is set irrespective of whether the file exists or not
        cls.filepath_original_mdl = os.path.splitext(cls.filepath_slx)[0] + '_org.mdl'
        cls.filepath_original_mdl_preetified = os.path.join(cls.dirpath_working, 'original_preetified.mdl')

        cls.dirpath_slx_extracted = os.path.abspath(os.path.join(cls.dirpath_working, 'slx-files'))
        cls.filepath_merged_commented = os.path.abspath(os.path.join(cls.dirpath_working, 'merged_commented.xml'))
        cls.filepath_merged_uncommented = os.path.abspath(os.path.join(cls.dirpath_working, 'merged_uncommented.xml'))
        cls.filepath_merged_commented_no_multiline_str_content = os.path.abspath(os.path.join(cls.dirpath_working, 'merged_commented_no_multiline_str_content.xml'))
        cls.filepath_merged_uncommented_no_multiline_str_content = os.path.abspath(os.path.join(cls.dirpath_working, 'merged_uncommented_no_multiline_str_content.xml'))

        cls.filepath_output_model_only_unpreetified = os.path.abspath(os.path.join(cls.dirpath_working, 'output_model_only_unpreetified.mdl'))
        cls.filepath_output_model_only_preetified = os.path.abspath(os.path.join(cls.dirpath_working, 'output_model_only_preetified.mdl'))

        cls.filepath_output_stateflow_only = os.path.abspath(os.path.join(cls.dirpath_working, 'output_stateflow_only.mdl'))

        cls.filepath_mdl_unpreetified = os.path.abspath(os.path.join(cls.dirpath_working, 'output.mdl'))
        cls.filepath_mdl_preetified = os.path.abspath(os.path.join(cls.dirpath_working, 'output_preetified.mdl'))

        cls.filepath_stateflow = os.path.abspath(os.path.join(cls.dirpath_working, 'slx-files', 'simulink', 'stateflow.xml'))
        cls.filepath_stateflow_preprocessed = os.path.abspath(os.path.join(cls.dirpath_working, 'stateflow-preprocessed.xml'))

        print(f"filepath_slx                    : {cls.filepath_slx}")
        print(f"filepath_mdl                    : {cls.filepath_mdl}")
        print(f"filepath_original_mdl, if any   : {cls.filepath_original_mdl}")
        print(f"dirpath_working                 : {cls.dirpath_working}")

        # remove previous files and  create all necessary files/folders
        Utils.remove_file(cls.filename_original_mdl_at_current_directory)
        Utils.remove_file(cls.filename_output_mdl_at_current_directory)
        Utils.remove_file(cls.filepath_mdl)
        Utils.remove_dirpath(cls.dirpath_working)
        Utils.create_dirpath(cls.dirpath_working)
        Utils.create_file(cls.filepath_mdl)

    @classmethod
    def _preprocess_stateflow(cls, input_filepath, output_filepath):
        with open(cls.filepath_stateflow) as rfile:
            rfile.readline()  # skip first line
            with open(output_filepath, 'w') as wfile:  # intermediate output in output_filepath
                for line in rfile:
                    wfile.write(line)
        Utils.str_contents_multiline_to_singleline(input_filepath=output_filepath, output_filepath=output_filepath)  # write in same file

    @classmethod
    def transform(cls):
        """Transform the slx file at cls.filepath_slx to mdl file
        and save it in cls.filepath_mdl """

        cls._extract_slx_archive()
        cls._merge_xmls(output_filepath=cls.filepath_merged_commented)

        Utils.uncomment_xml_file(input_filepath=cls.filepath_merged_commented, output_filepath=cls.filepath_merged_uncommented)
        Utils.str_contents_multiline_to_singleline(input_filepath=cls.filepath_merged_commented, output_filepath=cls.filepath_merged_commented_no_multiline_str_content)
        Utils.str_contents_multiline_to_singleline(input_filepath=cls.filepath_merged_uncommented, output_filepath=cls.filepath_merged_uncommented_no_multiline_str_content)

        # transform Model
        with open(cls.filepath_merged_uncommented_no_multiline_str_content) as file:
            xml = file.read()
        xml = xml.strip()
        modelOrLibrary = ModelOrLibrary(xml, parent_xml=None)
        mdl = modelOrLibrary.strmdl
        with open(cls.filepath_output_model_only_unpreetified, 'w') as file:
            file.write(mdl)

        
        Utils.copy_file(cls.filepath_output_model_only_unpreetified, cls.filepath_mdl_unpreetified)
        
        if cls._preetify:             
            Utils.preetify_mdl_file(cls.filepath_output_model_only_unpreetified, cls.filepath_output_model_only_preetified)
            Utils.copy_file(cls.filepath_output_model_only_preetified, cls.filepath_mdl_preetified)
        
        # handle stateflow
        if os.path.exists(cls.filepath_stateflow):
            # transform Statelfow
            cls._preprocess_stateflow(input_filepath=cls.filepath_stateflow, output_filepath=cls.filepath_stateflow_preprocessed)
            with open(cls.filepath_stateflow_preprocessed) as file:
                stfl_xml = file.read()
                stfl_mdl = stateflow_xml2mdl(stfl_xml)  # stateflow transformation
            with open(cls.filepath_output_stateflow_only, 'w') as file:
                file.write(stfl_mdl)

            # Append stateflow content to both unpreetified as well as preetified versions of mdl file
            with open(cls.filepath_mdl_unpreetified, 'a') as file:
                file.write(stfl_mdl)
            if cls._preetify:
                with open(cls.filepath_mdl_preetified, 'a') as file:
                    file.write(stfl_mdl)

        # copy file
        # preetifying output may introduce error in the mdl file,
        # so the unpreetified version is copied as the output to filepath_mdl
        shutil.copyfile(cls.filepath_mdl_unpreetified, cls.filepath_mdl)
        Utils.copy_file(cls.filepath_mdl, 'output.mdl', ignore_same_file_error=True)
        Utils.copy_file(cls.filepath_slx, 'original.slx', ignore_same_file_error=True)
        Utils.copy_file(cls.filepath_slx, os.path.join(cls.dirpath_working, 'original.slx'))
        if os.path.exists(cls.filepath_original_mdl):
            Utils.copy_file(cls.filepath_original_mdl, os.path.join(cls.dirpath_working,  'original.mdl'))
            Utils.copy_file(cls.filepath_original_mdl, 'original.mdl')
            if cls._preetify:
                Utils.preetify_mdl_file(cls.filepath_original_mdl, cls.filepath_original_mdl_preetified)


        # notify user if preetifying failed.
        # In case preetifying with TXL fails, nothing is written to output_model_only_preetified.mdl 
        if cls._preetify:
            with open(cls.filepath_output_model_only_preetified) as file: 
                content = file.read() 
                if not content: 
                    print('\nATTENTIION: Preetifying the output mdl file using TXL grammar failed!!!')
                    print('            Please, discard the preetified version in working directory.\n')

def main():
    Utils.verify_args(sys.argv)
    Transformer.initialize(
        filepath_slx=sys.argv[1],
        dirpath_working='working-dir',
        filepath_mdl='output.mdl', 
        preetify=True  
    )
    Transformer.transform()


def transform_all(modelset):
    assert modelset in [
        'automotive', 
        'design-model-architecture',
        'design-model-behavior',  
        'simulink_general'
    ]
    import glob
    slxs = glob.glob(f'simulink-models/{modelset}/*.slx')

    count = 0
    for filepath in slxs:
        count += 1
        print(f"\ncount: {count}/{len(slxs)}", end=' ')
        if count > 100:
            print(f"skipping : {filepath}")

        else:
            print(f"================== {filepath} ==================\n\n")

            # only filename (no path, no ext)
            filename = filepath.split('/')[-1].split('.')[0]
            filepath_without_ext = filepath[:-4]
            filepath_mdl = f"{filename}_output.mdl"
            dirpath_working = f'working-dir-{modelset}/{filename}'

            Transformer.initialize(
                filepath_slx=filepath,
                dirpath_working=dirpath_working,
                filepath_mdl='output.mdl'
            )
            Transformer.transform()


def test():
    with open('input.xml') as file:
        xml = file.read()

    Utils.str_contents_multiline_to_singleline('input.xml', 'output.xml')


if __name__ == '__main__':

    # transform_all('automotive')
    # transform_all('design-model-architecture')
    # transform_all('simulink-general')
    transform_all('design-model-behavior')
    
    # main()
    # test()
